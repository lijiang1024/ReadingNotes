
# 第一行代码 第二版 读书笔记

>
> 本书是 Android 程序开发的学习参考书籍
>
> Google Android官方地址 ：
>   * [Android国内官方地址](https://developer.android.google.cn)
>   * [Android官方地址](https://developer.android.com)
> 

## 第一章

-----

#### <span style="color: white;">1、Android系统架构</span>

> *<span style="color: grey;">Android大致可分为四层架构：Linux内核层、系统运行库层、应用框架层 和 应用层</span>*

1. Linux内核层
    * Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动。

2. 系统运行库层
    * 通过一些 C/C++ 库来为Android系统提供主要的特性支持。
    * 包含Android运行时库，提供了一些核心库，能够允许开发者使用Java语言编写Android应用。Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境）。

3. 应用框架层
    * 提供了构建应用程序时可能用到的各种API。

4. 应用层
    * 所有安装在手机上的应用程序都属于这一层。



**Android系统架构**

![Android系统架构](https://developer.android.google.cn/guide/platform/images/android-stack_2x.png)

-----

#### <span style="color: white;">2、Android应用开发特色</span>

1. 四大组件
    * Activity
    * Service
    * Broadcast Receiver
    * Content Provider

2. 丰富的系统控件

3. SQLite数据库
    
    > *<span style="color: grey;">SQLite数据库 是一种轻量级、运算速度极快的嵌入式关系型数据库</span>*

4. 强大的多媒体

5. 地理位置定位

-----

#### <span style="color: white;">3、Android Studio创建的Android项目的结构解析（HelloWorld）</span>

```
-- HelloWorld\
   |-- .gradle\
   |-- .idea\
   |-- app\
   |   |-- build\
   |   |-- libs\
   |   |-- src\
   |   |   |-- androidTest\
   |   |   |-- main\
   |   |   |   |-- java\
   |   |   |   |-- res\
   |   |   |   |   |-- drawable\
   |   |   |   |   |-- layout\
   |   |   |   |   |-- mipmap-hdpi\ 
   |   |   |   |   |-- mipmap-mdpi\
   |   |   |   |   |-- mipmap-xhdpi\
   |   |   |   |   |-- mipmap-xxhdpi\
   |   |   |   |   |-- mipmap-xxxhdpi\
   |   |   |   |   |-- values\
   |   |   |   |   |-- values-w820dp\
   |   |   |   |-- AndroidManifest.xml
   |   |   |
   |   |   |-- test\
   |   |
   |   |-- .gitignore
   |   |-- app.iml
   |   |-- build.gradle
   |   |-- proguard-rules.pro
   |   
   |-- build\
   |-- gradle\
   |-- .gitignore
   |-- build.gradle
   |-- gradle.properties
   |-- gradlew
   |-- gradlew.bat
   |-- HelloWorld.iml
   |-- local.properties
   |-- settings.gradle
```

1. **项目结构解析**
    
    * .gradle\ 和 .idea\

        这两个目录下放的是Android Studio自动生成的一些文件，无需关心，也不要去手动编辑。

    * app\

        项目中的代码、资源等内容几乎都放在这个目录下面。

    * build\

        这个目录不需要关心，它主要包含了一些在编译时自动生成的文件

    * gradle\

        这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式，不需要提前将gralde下载好，而是会自动根据本地缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏 --> File --> Settings --> Build, Execution, Deployment --> Gradle，进行配置更改。

    * .gitignore

        这个文件是用来将指定的目录或文件排除在版本控制之外

    * build.gradle

        这是项目全局的gradle构建脚本，通常这个文件是不需要修改的。

    * gradle.properties

        这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本

    * gradlew 和 gradlew.bat

        这两个文件是用来在命令行界面执行gradle命令的，其中gradlew是在 Linux 或 Mac 系统中使用的，gradlew.bat是在 Windows 系统中使用的。

    * HelloWorld.iml

        iml文件是所有 IntelliJ IDEA 项目都会自动生成的一个文件（Android Studio 是基于IntelliJ IDEA 开发的）

    * local.properties

        这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们不需要修改。

    * settings.gradle

        这个文件用于指定项目中所有引入的模块。通常情况下，模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少。

2. **app目录结构解析**

    * build\

        这个目录和外层的 build 目录类似，主要也是包含了一些在编译时自动生成的文件。

    * libs\

        如果项目中使用到第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。

    * androidTest\

        这个目录是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。

    * java\

        java目录是放置项目中的Java代码的地方。

    * res\

        在项目中使用的所有图片、布局、字符串等资源都要存放在这个目录下。这个目录中还有很多子目录，图片放在drawable目录下，布局文件放在layout目录下，字符串放在values目录下，

        > drawable开头的目录都是用来存放图片的；mipmap开头的目录都是用来存放应用图标的；values开头的目录都是用来存放字符串、样式、颜色等配置的；layout开头的目录是用来存放布局文件的。

    * AndroidManifest.xml

        这是整个Android项目的配置文件，在程序中定义的四大组件都需要在这个文件里注册，还可以在这个文件中给应用添加权限声明。

    * test\

        这个目录是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。

    * .gitignore

        这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的gitignore文件类似。

    * app.iml

        IntelliJ IDEA 项目自动生成的文件，不需要关心或修改这个文件中的内容。

    * build.grade

        这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。

    * proguard-rules.pro

        这个文件用于指定项目代码的混淆规则。


3. <b>build.gradle详解</b>

    > Android Studio采用Gradle构建项目。Gradle是一个非常先进的项目构建工具，使用一种基于Groovy的领域特定语言（DSL）来声明项目设置。
    
    * <b><i>外层目录的build.gradle文件中的代码</i></b>
        ```
            buildscript {
                repositories {
                    jcenter()
                }
                dependencies {
                    classpath 'com.android.tools.build:gradle:2.2.3'

                    // NOTE: Do not place your application dependencies here; they belong
                    // in the individual module build.gradle files
                }
            }

            allprojects {
                repositories {
                    jcenter()
                }
            }

            task clean(type: Delete) {
                delete rootProject.buildDir
            }
        ```
    
        * 首先两处 repositories 闭包中都声明了 jcenter() 配置， jcenter 是一个代码托管仓库，很多Android项目都会选择将代码托管到 jcenter 上，声明这行配置之后，就可以在项目中轻松引用 jcenter 上的开源项目了。

        * dependencies 闭包中使用 classpath 声明了一个Gradle插件。如果想使用Gradle构建Android项目，则需要声明 com.android.tools.build:gradle:2.2.3 这个插件。其中最后的部分是插件的版本号。

        > 通常不需要修改外层目录下的build.gradle文件，除非想添加一些全局的项目构建配置。

    * <b><i>app目录的build.gradle文件中的代码</i></b>
        ```
            apply plugin: 'com.android.application'

            android {
                compileSdkVersion 25
                buildToolsVersion "25.0.0"
                defaultConfig {
                    applicationId "org.liti.helloandroid"
                    minSdkVersion 19
                    targetSdkVersion 25
                    versionCode 1
                    versionName "1.0"
                    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
                }
                buildTypes {
                    release {
                        minifyEnabled false
                        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
                    }
                }
            }

            dependencies {
                compile fileTree(dir: 'libs', include: ['*.jar'])
                androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
                    exclude group: 'com.android.support', module: 'support-annotations'
                })
                compile 'com.android.support:appcompat-v7:25.0.1'
                compile 'com.android.support:design:25.0.1'
                testCompile 'junit:junit:4.12'
                compile 'com.orhanobut:logger:1.15'
            }
        ```
        
        * 第一行应用了一个插件，一般有两种值可选： com.android.application 表示这是一个应用程序模块； com.android.library 表示这是一个库模块。【两者的区别，应用程序模块可以直接运行，库模块只能作为代码依附于应用程序模块来运行】

        * android闭包，在这个闭包中可以配置项目构建的各种属性
            
            * compileSdkVersion 用于指定项目的编译版本
            
            * buildToolsVersion 用于指定项目构建工具的版本
            
            * defaultConfig闭包 在这里面可以对项目的更多细节进行配置

                * applicationId 用于指定项目的包名

                * minSdkVersion 用于指定项目最低兼容的Android系统版本

                * targetSdkVersion 指定的值表示在该目标版本上已经做了充分的测试，系统将会为你的应用程序启用一些最新的功能和特性

                * versionCode 用于指定项目的版本号

                * versionName 用于指定项目的版本名称

            * buildTypes闭包 用于指定生成安装文件的相关配置，通常只会有两个闭包，一个是debug【debug闭包用于指定生成测试版安装文件的配置】，一个是release【release闭包用于生成正式版安装文件的配置】。

                * release闭包的内容：minifyEnabled 用于指定是否对项目的代码进行混淆，true表示混淆，false表示不混淆；proguardFiles 用于指定混淆时使用的规则文件【这里指定了两个混淆文件：第一个proguard-android.txt 是在AndroidSDK目录下的，里面是所有项目的通用混淆规则；第二个proguard-rules.pro 是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则】。

        * dependencies闭包 可以指定当前项目所有的依赖关系。
            > 通常Android Studio 项目有3种依赖方式：本地依赖、库依赖 和 远程依赖
        
            * 本地依赖 可以对本地的jar包或目录添加依赖关系【compile fileTree(dir: 'libs', include: ['*.jar'])】

            * 库依赖 可以对项目中的库模块添加依赖关系【比如有个一库模块名字叫helper，添加库依赖的声明语句为 compile project(':helper')】

            * 远程依赖 可以对 jcenter 库上的开源项目添加依赖关系【compile 'com.orhanobut:logger:1.15'】

            * testCompile 用于声明测试用例库


-----
-----

## 第二章 探究Activity

-----

#### Activity之间跳转 -- Intent

> Intent 是 Android程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。 


Intent 大致可以分为两种： **显示Intent** 和 **隐时式Intent**

* 显示Intent：

    Intent有多个构造函数重载，其中一个是：
    
    ```
        Intetn(Context packageContext, Class<?> cls)

        * 第一个参数：要求提供一个启动Activity的上下文
        * 第二个参数：指定想要启动的目标Activity
    ```

* 隐式Intent

    隐式Intent不明确指出要启动的Activity，而是指定一系列更为抽象的 **action** 和 **category** 等信息，然后由系统去分析Intent，并找出合适的Activity去启动

    通过在AndroidManifest.xml文件的 **<activity>** 标签下配置 **<intent-filter>** 的内容，可以指定当前的Activity能够响应的 **action** 和 **category** 

    ```
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    ```

    > 每个Intent中只能指定一个action，但能够指定多个category。

    ```
        Intent intent = new Intent("action的标识串");
        intent.addCategory("category的标识串");
    ```

* 更多隐式Intent的用法

    * 调用系统的浏览器打开网页
    ```
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.prase("http://www.baidu.com"));
        startActivity(intent);
    ```

    > 可以在 <intent-filter> 标签中配置一个 <data>标签，用于更精确地指定当前活动能够响应什么类型的数据。<data>标签中主要可以配置一下内容：<br/>
    > > * android:scheme 用于指定数据的协议部分，比如上面例子中的http部分<br/>
    > > * android:host 用于指定数据的主机部分，比如上面例子中的 www.baidu.com 部分<br/>
    > > * android:port 用于指定数据的端口部分，一般紧随主机名之后<br/>
    > > * android:path 用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容<br/>
    > > * android:mimeType 用于指定可以处理的数据类型，允许使用通配符的方式进行指定<br/>

    ```
        <activity android:name=".ThirdActivity">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="http" />
            </intent-filter>
        </activity>

    ```

    * 其他协议
        * geo 表示显示地理位置
        * tel 表示拨打电话

        ```
            Intent intent = new Intent(Intent.ACTION_DIAL);
            intent.setData(Uri.prase("tel:10086"));
            startActivity(intent);
        ```
    
-----

#### Android Activity 生命周期

* 返回栈

> Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的Activity的集合，这个栈也被成为返回栈（Back Stack）。


* Activiy的状态
    
    * 运行状态
        > 当Activity位于返回栈栈顶时，就处于运行状态。

    * 暂停状态
        > 当Activity不再处于栈顶位置，但是仍然可见时，就进入了暂停状态
    
    * 停止状态
        > 当Activity不再处于栈顶位置，且完全不可见时，就进入了停止状态
    
    * 销毁状态
        > 当Activity从返回栈中移除后，就变成了销毁状态


* Activity的生命周期

    * Activity中定义了7个方法，覆盖了活动生命周期的每一个环节

        * onCreate()
            > 在Activity第一次被创建的时候调用。

        * onStart()
            > 在Activity由不可见变为可见的时候调用。

        * onResume()
            > 在Activity准备好和用户进行交互的时候调用。此时Activity一定厨卫返回栈的栈顶，并且处于运行状态。

        * onPause()
            > 在系统准备去启动或恢复另一个Activity的时候调用。

        * onStop()
            > 在Activity完全不可见的时候调用。

        * onDestory()
            > 在Activity被销毁之前调用。

        * onRestart()
            > 在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。

    * 以上7个方法，除onRestart()方法外，其他都是两两相对，因此可以将活动分为3种生存期

        * 完整生存期
            > onCreate() ---> onDestory()

        * 可见生存期
            > onStart() ---> onStop()

        * 前台生存期
            > onResume() ---> onPause()


<div style="background-color:white; width: 513px; height: 663px;">

![Activity LifeCycele](https://developer.android.google.cn/images/activity_lifecycle.png)

</div><br/><br/><br/>


https://developer.android.com/images/activity_lifecycle.png

https://developer.android.com/images/fragment_lifecycle.png

-----

#### Activity的启动模式

> Activity 的启动模式有4种：standard、singleTop、singleTask、singleInstance，可以在AndroidManifest.xml文件中通过给 <activity> 标签指定 android:launchMode属性来选择启动模式

    

* standard 

    > 是Activity的默认启动模式。在 standard 模式下，每当启动一个新的Activity，它都会在返回栈中入栈，并处于栈顶位置。
    
* singleTop

    > 在 singleTop 模式下，在启动Activity时，如果发现返回栈的栈顶已经是该Activity的实例，则认为可以直接使用它，不会再创建新的Activity实例； 如果返回栈栈顶的活动不是该Activity的实例，此时启动Activity会创建新的Activity实例。

* singleTask
        
    > 在 singleTask 模式下，在启动Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并且把在这个Activity之上的所有Activity统统出栈，如果没有发现就是创建一个新的Activity实例

* singleInstance
        
    > 指定为 singleInstance 模式的Activity，在启动Activity时会启用一个新的返回栈来管理这个活动【其实如果 singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈】。


_ _ _ _ _
-----

## 第三章 UI开发的点点滴滴

-----

#### 制作 Nine-Patch图片
> 在Android SDK 目录下有一个tools目录 有个draw9patch.bat的文件，可以用它来制作Nine-Patch图片。

* 制作Nine-Patch图片时，在 draw9patch 程序中导入图片，在图片的四个边框绘制一个个小黑点
    * 上边框 和 左边框 的绘制区域，表示图片的拉伸区域
    * 下边框 和 右边框 的绘制区域，表示图片中内容的显示区域

    > 使用鼠标🖱在图片边缘拖动，就可以绘制了；按住Shift键拖动鼠标可以进行擦除绘制。


-----
-----

## 第四章 探究Fragment

> Fragment 是一种能够嵌入在Activity中的UI片段，它能够让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用的非常广泛。

-----

#### Fragment的使用方式

* Fragment的简单用法

    * 新建一个Java类LeftFragment，并让它集成Fragment类，有两个不同包下的Fragment类供选择，一个是系统内置的Android.app.Fragment，另一个是 support-v4 库中提供的android.support.v4.app.Fragment。强烈建议使用support-v4库中的Fragment。

    * 在LeftFragment类中重写Fragment的 onCreateView()方法，在这个方法中通过LayoutInflater的inflate()方法加载对应的布局文件。

    * 在要使用Fragment的布局文件中通过 <fragmnet> 标签加载Fragment

    ```
        <fragment 
            android:id="@+id/left_fragment"
            android:name="*.*.LeftFragment"
            android:layout_width=""
            android:layout_height="match_parent"
            android:layout_weight="1" />
    ```

        > 通过Android:name属性显示指明要添加的Fragment的类名，️⚠️注意一定要将类名的包名也带上。


* 动态添加Fragment

    1. 创建待添加的Fragment的实例。
    2. 获取FragmentManager，在Activity中可以直接调用 **getSupportFragmentManager()** 方法得到。
    3. 开启一个事务，通过调用 **beginTransaction()** 方法开启。
    4. 向容器内添加或替换Fragment，一般用 **replace()** 方法实现，需要传入容器的id和待添加的Fragment的实例。
    5. 提交事务，调用 **commit()** 方法来完成

    > 在Fragment中模拟返回栈，在 FragmentTransaction 事务提交【调用commit()方法】前，调用 addToBackStack()方法，可以将一个事务添加到返回栈中。


#### Fragment的生命周期

* Fragment的状态和回掉函数

    * 运行状态
        > 当一个Fragment是可见的，并且它所关联的活动正处于运行状态时，该Fragment也处于运行状态。

    * 暂停状态
        > 当一个Activity进入暂停状态时(由于另一个未占满屏幕的Activity被添加到了栈顶)，与它相关联的可见Fragment就会进入到暂停状态。

    * 停止状态
        > 当一个Activity进入停止状态时，与它相关联的Fragment就会进入到停止状态，或者通过调用FragmentTransaction 的 remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前调用addtoBackStack()方法，这是Fragment也会进入到停止状态。

    * 销毁状态
        > Fragment 总是依附于Activity而存在的，因此当Activity被销毁时，与它相关联的Fragment就会进入到销毁状态。或者通过调用FragmentTransaction 的 remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前没有调用addtoBackStack()方法，这是Fragment也会进入到销毁状态。

    >
    > **重点看几个回掉函数**
    >
    > > **onAttach()** 当Fragment和Activity建立关联的时候调用
    > 
    > > **onCreateView()** 为Fragment创建视图（加载布局）时调用
    >
    > > **onActivityCreated()** 确保与Fragment的相关Activity一定已经创建完毕的时候调用
    >
    > > **onDestoryView()** 当于Fragment关联的视图被移除的时候调用
    >
    > > **onDetach()** 挡Fragment 和 Activity解除关联的时候调用。
    >

<div style="background-color:white; width: 317px; height: 847px;">

![Fragment LifeCycele](https://developer.android.google.cn/images/fragment_lifecycle.png)

</div><br/><br/>

#### 动态加载布局的技巧

* 使用限定符【Qualifiers】
    > 例如: layout-large

    **Android中一些常见的限定符**

   


-----









