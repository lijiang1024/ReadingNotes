
# 第一行代码 第二版 读书笔记

>
> 本书是 Android 程序开发的学习参考书籍
>
> Google Android官方地址 ：
>   * [Android国内官方地址](https://developer.android.google.cn)
>   * [Android官方地址](https://developer.android.com)
> 

## 第一章

-----

#### <span style="color: white;">1、Android系统架构</span>

> *<span style="color: grey;">Android大致可分为四层架构：Linux内核层、系统运行库层、应用框架层 和 应用层</span>*

1. Linux内核层
    * Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动。

2. 系统运行库层
    * 通过一些 C/C++ 库来为Android系统提供主要的特性支持。
    * 包含Android运行时库，提供了一些核心库，能够允许开发者使用Java语言编写Android应用。Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境）。

3. 应用框架层
    * 提供了构建应用程序时可能用到的各种API。

4. 应用层
    * 所有安装在手机上的应用程序都属于这一层。



**Android系统架构**

![Android系统架构](https://developer.android.google.cn/guide/platform/images/android-stack_2x.png)

-----

#### <span style="color: white;">2、Android应用开发特色</span>

1. 四大组件
    * Activity
    * Service
    * Broadcast Receiver
    * Content Provider

2. 丰富的系统控件

3. SQLite数据库
    
    > *<span style="color: grey;">SQLite数据库 是一种轻量级、运算速度极快的嵌入式关系型数据库</span>*

4. 强大的多媒体

5. 地理位置定位

-----

#### <span style="color: white;">3、Android Studio创建的Android项目的结构解析（HelloWorld）</span>

```
-- HelloWorld\
   |-- .gradle\
   |-- .idea\
   |-- app\
   |   |-- build\
   |   |-- libs\
   |   |-- src\
   |   |   |-- androidTest\
   |   |   |-- main\
   |   |   |   |-- java\
   |   |   |   |-- res\
   |   |   |   |   |-- drawable\
   |   |   |   |   |-- layout\
   |   |   |   |   |-- mipmap-hdpi\ 
   |   |   |   |   |-- mipmap-mdpi\
   |   |   |   |   |-- mipmap-xhdpi\
   |   |   |   |   |-- mipmap-xxhdpi\
   |   |   |   |   |-- mipmap-xxxhdpi\
   |   |   |   |   |-- values\
   |   |   |   |   |-- values-w820dp\
   |   |   |   |-- AndroidManifest.xml
   |   |   |
   |   |   |-- test\
   |   |
   |   |-- .gitignore
   |   |-- app.iml
   |   |-- build.gradle
   |   |-- proguard-rules.pro
   |   
   |-- build\
   |-- gradle\
   |-- .gitignore
   |-- build.gradle
   |-- gradle.properties
   |-- gradlew
   |-- gradlew.bat
   |-- HelloWorld.iml
   |-- local.properties
   |-- settings.gradle
```

1. **项目结构解析**
    
    * .gradle\ 和 .idea\

        这两个目录下放的是Android Studio自动生成的一些文件，无需关心，也不要去手动编辑。

    * app\

        项目中的代码、资源等内容几乎都放在这个目录下面。

    * build\

        这个目录不需要关心，它主要包含了一些在编译时自动生成的文件

    * gradle\

        这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式，不需要提前将gralde下载好，而是会自动根据本地缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏 --> File --> Settings --> Build, Execution, Deployment --> Gradle，进行配置更改。

    * .gitignore

        这个文件是用来将指定的目录或文件排除在版本控制之外

    * build.gradle

        这是项目全局的gradle构建脚本，通常这个文件是不需要修改的。

    * gradle.properties

        这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本

    * gradlew 和 gradlew.bat

        这两个文件是用来在命令行界面执行gradle命令的，其中gradlew是在 Linux 或 Mac 系统中使用的，gradlew.bat是在 Windows 系统中使用的。

    * HelloWorld.iml

        iml文件是所有 IntelliJ IDEA 项目都会自动生成的一个文件（Android Studio 是基于IntelliJ IDEA 开发的）

    * local.properties

        这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们不需要修改。

    * settings.gradle

        这个文件用于指定项目中所有引入的模块。通常情况下，模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少。

2. **app目录结构解析**

    * build\

        这个目录和外层的 build 目录类似，主要也是包含了一些在编译时自动生成的文件。

    * libs\

        如果项目中使用到第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。

    * androidTest\

        这个目录是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。

    * java\

        java目录是放置项目中的Java代码的地方。

    * res\

        在项目中使用的所有图片、布局、字符串等资源都要存放在这个目录下。这个目录中还有很多子目录，图片放在drawable目录下，布局文件放在layout目录下，字符串放在values目录下，

        > drawable开头的目录都是用来存放图片的；mipmap开头的目录都是用来存放应用图标的；values开头的目录都是用来存放字符串、样式、颜色等配置的；layout开头的目录是用来存放布局文件的。

    * AndroidManifest.xml

        这是整个Android项目的配置文件，在程序中定义的四大组件都需要在这个文件里注册，还可以在这个文件中给应用添加权限声明。

    * test\

        这个目录是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。

    * .gitignore

        这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的gitignore文件类似。

    * app.iml

        IntelliJ IDEA 项目自动生成的文件，不需要关心或修改这个文件中的内容。

    * build.grade

        这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。

    * proguard-rules.pro

        这个文件用于指定项目代码的混淆规则。


3. <b>build.gradle详解</b>

    > Android Studio采用Gradle构建项目。Gradle是一个非常先进的项目构建工具，使用一种基于Groovy的领域特定语言（DSL）来声明项目设置。
    
    * <b><i>外层目录的build.gradle文件中的代码</i></b>
        ```
            buildscript {
                repositories {
                    jcenter()
                }
                dependencies {
                    classpath 'com.android.tools.build:gradle:2.2.3'

                    // NOTE: Do not place your application dependencies here; they belong
                    // in the individual module build.gradle files
                }
            }

            allprojects {
                repositories {
                    jcenter()
                }
            }

            task clean(type: Delete) {
                delete rootProject.buildDir
            }
        ```
    
        * 首先两处 repositories 闭包中都声明了 jcenter() 配置， jcenter 是一个代码托管仓库，很多Android项目都会选择将代码托管到 jcenter 上，声明这行配置之后，就可以在项目中轻松引用 jcenter 上的开源项目了。

        * dependencies 闭包中使用 classpath 声明了一个Gradle插件。如果想使用Gradle构建Android项目，则需要声明 com.android.tools.build:gradle:2.2.3 这个插件。其中最后的部分是插件的版本号。

        > 通常不需要修改外层目录下的build.gradle文件，除非想添加一些全局的项目构建配置。

    * <b><i>app目录的build.gradle文件中的代码</i></b>
        ```
            apply plugin: 'com.android.application'

            android {
                compileSdkVersion 25
                buildToolsVersion "25.0.0"
                defaultConfig {
                    applicationId "org.liti.helloandroid"
                    minSdkVersion 19
                    targetSdkVersion 25
                    versionCode 1
                    versionName "1.0"
                    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
                }
                buildTypes {
                    release {
                        minifyEnabled false
                        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
                    }
                }
            }

            dependencies {
                compile fileTree(dir: 'libs', include: ['*.jar'])
                androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
                    exclude group: 'com.android.support', module: 'support-annotations'
                })
                compile 'com.android.support:appcompat-v7:25.0.1'
                compile 'com.android.support:design:25.0.1'
                testCompile 'junit:junit:4.12'
                compile 'com.orhanobut:logger:1.15'
            }
        ```
        
        * 第一行应用了一个插件，一般有两种值可选： com.android.application 表示这是一个应用程序模块； com.android.library 表示这是一个库模块。【两者的区别，应用程序模块可以直接运行，库模块只能作为代码依附于应用程序模块来运行】

        * android闭包，在这个闭包中可以配置项目构建的各种属性
            
            * compileSdkVersion 用于指定项目的编译版本
            
            * buildToolsVersion 用于指定项目构建工具的版本
            
            * defaultConfig闭包 在这里面可以对项目的更多细节进行配置

                * applicationId 用于指定项目的包名

                * minSdkVersion 用于指定项目最低兼容的Android系统版本

                * targetSdkVersion 指定的值表示在该目标版本上已经做了充分的测试，系统将会为你的应用程序启用一些最新的功能和特性

                * versionCode 用于指定项目的版本号

                * versionName 用于指定项目的版本名称

            * buildTypes闭包 用于指定生成安装文件的相关配置，通常只会有两个闭包，一个是debug【debug闭包用于指定生成测试版安装文件的配置】，一个是release【release闭包用于生成正式版安装文件的配置】。

                * release闭包的内容：minifyEnabled 用于指定是否对项目的代码进行混淆，true表示混淆，false表示不混淆；proguardFiles 用于指定混淆时使用的规则文件【这里指定了两个混淆文件：第一个proguard-android.txt 是在AndroidSDK目录下的，里面是所有项目的通用混淆规则；第二个proguard-rules.pro 是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则】。

        * dependencies闭包 可以指定当前项目所有的依赖关系。
            > 通常Android Studio 项目有3种依赖方式：本地依赖、库依赖 和 远程依赖
        
            * 本地依赖 可以对本地的jar包或目录添加依赖关系【compile fileTree(dir: 'libs', include: ['*.jar'])】

            * 库依赖 可以对项目中的库模块添加依赖关系【比如有个一库模块名字叫helper，添加库依赖的声明语句为 compile project(':helper')】

            * 远程依赖 可以对 jcenter 库上的开源项目添加依赖关系【compile 'com.orhanobut:logger:1.15'】

            * testCompile 用于声明测试用例库


-----
-----

## 第二章 探究Activity

-----

#### Activity之间跳转 -- Intent

> Intent 是 Android程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。 


Intent 大致可以分为两种： **显示Intent** 和 **隐时式Intent**

* 显示Intent：

    Intent有多个构造函数重载，其中一个是：
    
    ```
        Intetn(Context packageContext, Class<?> cls)

        * 第一个参数：要求提供一个启动Activity的上下文
        * 第二个参数：指定想要启动的目标Activity
    ```

* 隐式Intent

    隐式Intent不明确指出要启动的Activity，而是指定一系列更为抽象的 **action** 和 **category** 等信息，然后由系统去分析Intent，并找出合适的Activity去启动

    通过在AndroidManifest.xml文件的 **<activity>** 标签下配置 **<intent-filter>** 的内容，可以指定当前的Activity能够响应的 **action** 和 **category** 

    ```
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    ```

    > 每个Intent中只能指定一个action，但能够指定多个category。

    ```
        Intent intent = new Intent("action的标识串");
        intent.addCategory("category的标识串");
    ```

* 更多隐式Intent的用法

    * 调用系统的浏览器打开网页
    ```
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.prase("http://www.baidu.com"));
        startActivity(intent);
    ```

    > 可以在 <intent-filter> 标签中配置一个 <data>标签，用于更精确地指定当前活动能够响应什么类型的数据。<data>标签中主要可以配置一下内容：<br/>
    > > * android:scheme 用于指定数据的协议部分，比如上面例子中的http部分<br/>
    > > * android:host 用于指定数据的主机部分，比如上面例子中的 www.baidu.com 部分<br/>
    > > * android:port 用于指定数据的端口部分，一般紧随主机名之后<br/>
    > > * android:path 用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容<br/>
    > > * android:mimeType 用于指定可以处理的数据类型，允许使用通配符的方式进行指定<br/>

    ```
        <activity android:name=".ThirdActivity">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="http" />
            </intent-filter>
        </activity>

    ```

    * 其他协议
        * geo 表示显示地理位置
        * tel 表示拨打电话

        ```
            Intent intent = new Intent(Intent.ACTION_DIAL);
            intent.setData(Uri.prase("tel:10086"));
            startActivity(intent);
        ```
    
-----

#### Android Activity 生命周期

* 返回栈

> Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的Activity的集合，这个栈也被成为返回栈（Back Stack）。


* Activiy的状态
    
    * 运行状态
        > 当Activity位于返回栈栈顶时，就处于运行状态。

    * 暂停状态
        > 当Activity不再处于栈顶位置，但是仍然可见时，就进入了暂停状态
    
    * 停止状态
        > 当Activity不再处于栈顶位置，且完全不可见时，就进入了停止状态
    
    * 销毁状态
        > 当Activity从返回栈中移除后，就变成了销毁状态


* Activity的生命周期

    * Activity中定义了7个方法，覆盖了活动生命周期的每一个环节

        * onCreate()
            > 在Activity第一次被创建的时候调用。

        * onStart()
            > 在Activity由不可见变为可见的时候调用。

        * onResume()
            > 在Activity准备好和用户进行交互的时候调用。此时Activity一定厨卫返回栈的栈顶，并且处于运行状态。

        * onPause()
            > 在系统准备去启动或恢复另一个Activity的时候调用。

        * onStop()
            > 在Activity完全不可见的时候调用。

        * onDestory()
            > 在Activity被销毁之前调用。

        * onRestart()
            > 在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。

    * 以上7个方法，除onRestart()方法外，其他都是两两相对，因此可以将活动分为3种生存期

        * 完整生存期
            > onCreate() ---> onDestory()

        * 可见生存期
            > onStart() ---> onStop()

        * 前台生存期
            > onResume() ---> onPause()


<div style="background-color:white; width: 513px; height: 663px;">

![Activity LifeCycele](https://developer.android.google.cn/images/activity_lifecycle.png)

</div><br/><br/><br/>

-----

#### Activity的启动模式

> Activity 的启动模式有4种：standard、singleTop、singleTask、singleInstance，可以在AndroidManifest.xml文件中通过给 <activity> 标签指定 android:launchMode属性来选择启动模式

    

* standard 

    > 是Activity的默认启动模式。在 standard 模式下，每当启动一个新的Activity，它都会在返回栈中入栈，并处于栈顶位置。
    
* singleTop

    > 在 singleTop 模式下，在启动Activity时，如果发现返回栈的栈顶已经是该Activity的实例，则认为可以直接使用它，不会再创建新的Activity实例； 如果返回栈栈顶的活动不是该Activity的实例，此时启动Activity会创建新的Activity实例。

* singleTask
        
    > 在 singleTask 模式下，在启动Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并且把在这个Activity之上的所有Activity统统出栈，如果没有发现就是创建一个新的Activity实例

* singleInstance
        
    > 指定为 singleInstance 模式的Activity，在启动Activity时会启用一个新的返回栈来管理这个活动【其实如果 singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈】。


_ _ _ _ _
-----

## 第三章 UI开发的点点滴滴

-----

#### 制作 Nine-Patch图片
> 在Android SDK 目录下有一个tools目录 有个draw9patch.bat的文件，可以用它来制作Nine-Patch图片。

* 制作Nine-Patch图片时，在 draw9patch 程序中导入图片，在图片的四个边框绘制一个个小黑点
    * 上边框 和 左边框 的绘制区域，表示图片的拉伸区域
    * 下边框 和 右边框 的绘制区域，表示图片中内容的显示区域

    > 使用鼠标🖱在图片边缘拖动，就可以绘制了；按住Shift键拖动鼠标可以进行擦除绘制。


-----
-----

## 第四章 探究Fragment

> Fragment 是一种能够嵌入在Activity中的UI片段，它能够让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用的非常广泛。

-----

#### Fragment的使用方式

* Fragment的简单用法

    * 新建一个Java类LeftFragment，并让它集成Fragment类，有两个不同包下的Fragment类供选择，一个是系统内置的Android.app.Fragment，另一个是 support-v4 库中提供的android.support.v4.app.Fragment。强烈建议使用support-v4库中的Fragment。

    * 在LeftFragment类中重写Fragment的 onCreateView()方法，在这个方法中通过LayoutInflater的inflate()方法加载对应的布局文件。

    * 在要使用Fragment的布局文件中通过 <fragmnet> 标签加载Fragment

    ```
        <fragment 
            android:id="@+id/left_fragment"
            android:name="*.*.LeftFragment"
            android:layout_width=""
            android:layout_height="match_parent"
            android:layout_weight="1" />
    ```

        > 通过Android:name属性显示指明要添加的Fragment的类名，️⚠️注意一定要将类名的包名也带上。


* 动态添加Fragment

    1. 创建待添加的Fragment的实例。
    2. 获取FragmentManager，在Activity中可以直接调用 **getSupportFragmentManager()** 方法得到。
    3. 开启一个事务，通过调用 **beginTransaction()** 方法开启。
    4. 向容器内添加或替换Fragment，一般用 **replace()** 方法实现，需要传入容器的id和待添加的Fragment的实例。
    5. 提交事务，调用 **commit()** 方法来完成

    > 在Fragment中模拟返回栈，在 FragmentTransaction 事务提交【调用commit()方法】前，调用 addToBackStack()方法，可以将一个事务添加到返回栈中。


#### Fragment的生命周期

* Fragment的状态和回掉函数

    * 运行状态
        > 当一个Fragment是可见的，并且它所关联的活动正处于运行状态时，该Fragment也处于运行状态。

    * 暂停状态
        > 当一个Activity进入暂停状态时(由于另一个未占满屏幕的Activity被添加到了栈顶)，与它相关联的可见Fragment就会进入到暂停状态。

    * 停止状态
        > 当一个Activity进入停止状态时，与它相关联的Fragment就会进入到停止状态，或者通过调用FragmentTransaction 的 remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前调用addtoBackStack()方法，这是Fragment也会进入到停止状态。

    * 销毁状态
        > Fragment 总是依附于Activity而存在的，因此当Activity被销毁时，与它相关联的Fragment就会进入到销毁状态。或者通过调用FragmentTransaction 的 remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前没有调用addtoBackStack()方法，这是Fragment也会进入到销毁状态。

    >
    > **重点看几个回掉函数**
    >
    > > **onAttach()** 当Fragment和Activity建立关联的时候调用
    > 
    > > **onCreateView()** 为Fragment创建视图（加载布局）时调用
    >
    > > **onActivityCreated()** 确保与Fragment的相关Activity一定已经创建完毕的时候调用
    >
    > > **onDestoryView()** 当于Fragment关联的视图被移除的时候调用
    >
    > > **onDetach()** 挡Fragment 和 Activity解除关联的时候调用。
    >

<div style="background-color:white; width: 317px; height: 847px;">

![Fragment LifeCycele](https://developer.android.google.cn/images/fragment_lifecycle.png)

</div><br/><br/>

#### 动态加载布局的技巧

* 使用限定符【Qualifiers】
    > 例如: layout-large

    **Android中一些常见的限定符**

<table border="2">
  <tr>
    <td>屏幕特征</td>
    <td>限定符</td>
    <td>描述</td>
  </tr>
      <tr>
        <td rowspan="4">大小</td>
        <td>small</td>
        <td>提供给小屏幕设备的资源</td>
      </tr>
      <tr>
        <td>normal</td>
        <td>提供给中等屏幕设备的资源</td>
      </tr>
      <tr>
        <td>large</td>
        <td>提供给大屏幕设备的资源</td>
      </tr>
      <tr>
        <td>xlarge</td>
        <td>提供给超大屏幕设备的资源</td>
      </tr>
      <tr>
        <td rowspan="4">分辨率</td>
        <td>ldpi</td>
        <td>提供给低分辨率设备的资源（120dpi以下）</td>
      </tr>
      <tr>
        <td>mdpi</td>
        <td>提供给中等分辨率设备的资源（120dpi到160dpi）</td>
      </tr>
      <tr>
        <td>hdpi</td>
        <td>提供给高分辨率设备的资源（160dpi到240dpi）</td>
      </tr>
      <tr>
        <td>xhdpi</td>
        <td>提供给超高分辨率设备的资源（240dpi到320dpi）</td>
      </tr>
      <tr>
        <td rowspan="2">方向</td>
        <td>land</td>
        <td>提供给横屏设备的资源</td>
      </tr>
      <tr>
        <td>port</td>
        <td>提供给竖屏设备的资源</td>
      </tr>
</table><br/><br/>

-----
-----


## 第五章 *Broadcast Receiver*


-----

* Android中广播分为两种类型：1、<span style="color: red;"><b>标准广播</b></span> 2、<span style="color: red;"><b>有序广播</b></span>

    * 标准广播【Normal Broadcasts】：是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息。这种广播的效率会比较高，但它是无法被截断的。

    * 有序广播【Ordered Broadcasts】：是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。

* 注册广播：1、<span style="color: red;"><b>动态注册</b></span> 2、<span style="color: red;"><b>静态注册</b></span>

    * 动态注册：在代码中注册广播， registerReceiver(broadcastReceiver, intentFilter);
    * 静态注册：在 *AndroidManifest.xml* 中注册广播

* 创建广播接收器：新建一个Class，继承BroadcastReceiver，重写父类的onReceive()方法。这样当有广播到来时，onReceive()方法就会得到执行。

* 发送标准广播： *<b>sendBroadcast(intent);</b>*

* 发送有序广播： *<b>sendOrderedBroadcast(intent, null);</b>*  第二个参数是一个与权限相关的字符串，一般传null。

  设定有序广播的接收顺序：在 *AndroidMainfest.xml* 中 <span style="color: red;"><b>receiver</b></span> 中的 <span style="color: red;"><b>intent-filter android:priority="100"</b></span> 中设置广播接收器的优先级，优先级比较高的广播接收器可以先收到广播。 *<b>abortBroadcast()</b>* 可以截断有序广播的发送

* 本地广播 **在本地广播机制中，广播只能在应用程序内部进行传递，并且广播接收器只能接收来自本应用程序发出的广播**
  * 本地广播主要是使用 *<span style="color: red;"><b>LocalBroadcastManager</b></span>* 来对广播进行管理
    * 获取实例对象 
      
      ```
      LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
      ```
    * 注册本地广播监听器 
      ```
      IntentFilter intentFilter = new IntentFilter();
      intentFilter.addAction("org.liti.app.broadcast.LOCAL_BROADCAST");
      LocalBroadcasrReceiver localBroadcastReceiver = new LocalBroadcasrReceiver();
      localBroadcastManager.registerReceiver(localBroadcastReceiver, intentFilter);
      ```
    * 发送本地广播
      ```
      Intent intent = new Intent("org.liti.app.broadcast.LOCAL_BROADCAST");
      localBroadcastManager.sendBroadcast(intent);
      ```
    * 注销本地广播监听器
      ```
      localBroadcastManager.unregisterReceiver(localBroadcastReceiver);
      ```

  * 本地广播是无法通过静态注册的方式来接收的
  
  * 本地广播的优势
    > 
    > * 可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露
    > 
    > * 其他程序无法将广播发送到我们的程序内部，因此不需要担心会有安全漏洞的隐患
    >
    > * 发送本地广播比发送系统全局广播会更加高效
    > 

* **Git 版本控制工具**
  * 创建代码仓库
    * 配置身份
      ```
      git config --global user.name "Tony"
      git config --global user.email "tony@gmail.com"
      ```
    *配置完成后，可以使用同样的命令来查看是否配置成功，只需要将最后的名字和邮箱地址去掉即可*

    * 创建代码仓库(Repository)

      *仓库，是用于保存版本管理所需信息的地方，所有本地提交的代码都会被提交到代码仓库中，如果有需要还可以再推送到远程仓库中*

      在项目根目录下面，输入下面的命令就可以完成创建代码仓库的操作。
      ```
      git init
      ```
      仓库创建完成后，会在项目根目录下生成一个隐藏的 <span style="color: red;"><b><i>.git</i></b></span> 目录，这个目录就是用来记录本地所有的Git操作的。如果想要删除本地仓库，只需要删除这个目录就可以了。

  * 提交本地代码
    ```
    git add 文件名 //添加单个文件到仓库
    git add 目录名 //添加某个目录及目录中的所有文件到仓库
    git add .     //添加当前目录中所有文件到仓库

    git commit -m "提交到仓库的代码的备注信息" // 真正的提交代码到本地仓库
    ```

-----
-----

## 第六章 数据存储，数据持久化

------

#### 持久化技术

>
> 数据持久化就是指将内存中的瞬时数据保存到存储设备中
>
> 保存在内存中的数据是处于瞬时状态的
>
> 保存在存储设备中国年的数据是处于持久状态的
>
> 持久化技术是提供了一种机制可以让数据载瞬时状态和持久状态之间进行切换
>

* Android系统中的数据持久化功能
    * 文件存储
    * SharedPreference存储
    * 数据库存储

    *除了这三种方式外，还可以将数据保存在手机的SD卡中*

-----

#### 文件存储

* 将数据存储到文件中
    Context类中提供一个 openFileOutput(param1, param2) 方法，用于将数据存储到指定的文件中。这个方法接收两个参数：

    * 第一个参数是文件名，在文件创建的时候使用的就是这个名称，⚠️注意这里制定的文件名不可以包含路径，因为所有的文件都默认存储到 <span style="color: red;"><b><i>/data/data/< package name >/files/</i></b></span> 目录下面的。
    
    * 第二参数是文件的操作模式，主要有两种模式可选，<span style="color: red;"><b>MODE_PRIVATE</b></span> 和 <span style="color: red;"><b>MODE_APPEND</b></span>
        
        * MODE_PRIVATE：是默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容
        
        * MODE_APPEND：表示如果该文件已存在就往文件里面追加内容，不存在就创建新文件。
        
        ⚠️其实文件的操作模式本来还有另外两种，<span style="color: yellow;"><b>MODE_WORLD_READABLE</b></span> 和 <span style="color: yellow;"><b>MODE_WORLD_WRITEABLE</b></span>，这两种模式表示允许其他的应用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安全性漏洞，已在 <span style="color: green;"><b>Android 4.2</b></span> 版本中被废弃
        
        * openFileOutput(param1, param2) 方法返回的是一个FileOutputStream对象，得到这个对象后可以用 Java 流的方式将数据写入到文件

* 从文件中读取数据
    
    Context类中提供一个 openFileInput() 方法，用于从文件中读取数据。这个方法只有一个参数，即要读取的文件名。系统会自动到 <span style="color: red;"><b><i>/data/data/< package name >/files/</i></b></span> 目录下去加载这个文件，并返回一个FileInputStream 对象，得到这个对象后可以用 Java 流的方式将数据读取出来。       

-----

#### SharedPreferences 存储
  
> *SharedPreferences* 是使用键值对的方式来存储数据的。
>   
> *SharedPreferences* 还支持多种不同的数据类型存储。

* 要想使用 **SharedPreferences** 来存储数据，首先要获取到 **SharedPreferences** 对象。
    
    Android中主要提供三种方法用于得到 **SharedPreferences** 对象：
        
    * 1、Context类中的 **getSharedPreferences()** 方法
        > 此方法接收连个参数：
        >   * 第一个参数：用于指定 SharedPreferences 问价的名称，如果指定的文件不存在就会创建一个。
        >   * 第二个参数：用于指定操作模式，目前只有 **MODE_PRIVATE** 一种模式可选，它是默认的操作模式，和直接传入 **0** 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences 文件进行读写。
        >       > 其他几种模式均已被废弃，<span style="color: yellow;"><b>MODE_WORLD_READABLE</b></span> 和 <span style="color: yellow;"><b>MODE_WORLD_WRITEABLE</b></span> 这两种模式在 **Android 4.2** 中被废弃，<span style="color: yellow;"><b>MODE_MULTI_PROCESS</b></span> 模式在**Android 6.0** 中被废弃

    * 2、Activity类中的 **getPreferences()** 方法
        > 这个方法和 Context 中的 getSharedPreferences() 方法很相似，不过它只接收一个 **操作模式** 参数，这个方法将自动使用当前活动的类名作为 SharedPreferences 的文件名 
 
    * 3、PreferenceManager类中的 **getDefaultSharedPreferences()** 方法
        > 这是一个静态方法，它接收 Context 作为参数，并自动将当前应用程序的包名作为前缀来命名 SharedPreferences 文件。

    > SharedPreferences 文件都是存放在 **/data/data/< package name >/shared_prefs/** 目录下的。

* 得到 **SharedPreferences** 对象后，可以向 *SharedPreferences* 文件中存储数据了

    * 1、调用 SharedPreferences 对象的 **edit()** 方法来获取一个 **SharedPreferences.Editor** 对象。

    * 2、向 SharedPreferences.Editor 对象中添加数据
        > 例如：
        >   * 添加一个布尔型数据：putBoolean()方法
        >   * 添加一个字符串数据：putString()方法
        >   
    
    * 3、调用SharedPreferences.Editor.apply()方法将添加的数据提交，完成数据存储操作

    * 4、调用SharedPreferences.Editor.clear()方法可以将SharedPreferences文件中的数据全部清除掉。

* 从 SharedPreferences 中读取数据
    > SharedPreferences 对象提供了一些列的 get 方法用于对存储的数据进行读取。
    > 
    > > 这些 get 方法都接收两个参数。
    > > * 第一个参数是 key ，传入存储数据时使用的 key 就可以得到相应的值
    > > * 第二个参数是默认值，即表示当传入的key找不到对应的值时，就会返回默认值。

-----

### SQLite数据库存储

#### 1、创建数据库
> Android 为了让我们能够更加方便地管理数据库，专门提供了一个 **SQLiteOpenHelper** 帮助类，借助这个类可以非常简单的实现对数据库进行 **创建** 和 **升级**。

* **SQLiteOpenHelper** 是一个抽象类，使用时需要创建一个类继承 *SQLiteOpenHelper*类
        > *SQLiteOpenHelper* 类中有两个抽象方法，**onCreate()** 和 **onUpgrade()**，我们必须在自己的实现类中在这两个方法中去实现创建、和升级数据库的逻辑。

* **SQLiteOpenHelper** 类中有两个非常重要的实例方法：**getReadableDatabase()** 和 **getWritableDatabase()**。这两个方法都可以创建或打开一个现有数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。
        > 当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase()方法返回的对象将以只读的方式打开数据库，而getWritableDatabase()方法则将抛出异常。

* **SQLiteOpenHelper**中有两个构造方法可供重写，一般使用参数少一点的那个构造方法就可以了。

> **SQLite数据库的数据类型**
> > * **integer** 代表整型
> > * **real** 代表浮点型
> > * **text** 代表文本类型
> > * **blob** 代表二进制类型
    
```
    /**
     * 构造函数
     *
     * @param context 上下文环境，必须要有它才能对数据库进行操作
     * @param name 数据库名，创建数据库时使用的就是这里指定的名字
     * @param factory 允许我们在查询数据的时候返回的一个自定义的Cursor，一般都是传null
     * @param version 当前数据库的版本号，用于对数据库进行升级操作
     *
     */
    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
        super(context, name, factory, version);
        mContext = context;
    }

    // 构造函数2
    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler, Context mContext) {
        super(context, name, factory, version, errorHandler);
        this.mContext = mContext;
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(CREATE_BOOK);

        db.execSQL(CREATE_CATEGORY); // 在数据库中添加一张新表
        Toast.makeText(mContext, "创建数据表成功", Toast.LENGTH_SHORT).show();

    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

//        db.execSQL("drop table if exists Book");
//        db.execSQL("drop table if exists Category");
//        onCreate(db);
    }
```

#### 2、数据库操作
> 数据库操作分为4种，即CURD，其中C代表创建（Create），R代表查询（Retrieve），U代表更新（Update），D代表删除（Delete），每种操作对应一种SQL命令。
> 
> * 添加数据时使用 insert
> * 查询数据时使用 select
> * 更新数据时使用 update
> * 删除数据时使用 delete
>
> Android 提供了一系列的辅助性方法，使得在Android中即使不编写SQL语句，也能够轻松完成所有的CRUD操作。
> 
> 我们借助调用 SQLiteOpenHelper 的 getReadableDatabase() 和 getWritableDatabase()方法返回的 **SQLiteDatabase** 对象，对数据库进行CRUD操作 

* 1、添加数据

    > SQLiteDatabase 中提供了一个insert()方法用于添加数据，接收3个参数，如下：
    > * 第一个参数：表名，指定向那张数据表里添加数据
    > * 第二个参数：用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般不用这个功能，直接传入null即可
    > * 第三个参数：是一个 ContentValues 对象，它提供一系列的put()方法重载，用于向ContentValues中添加数据

    ```
        /**
         * Convenience method for inserting a row into the database.
         *
         * @param table the table to insert the row into
         * @param nullColumnHack optional; may be <code>null</code>.
         *            SQL doesn't allow inserting a completely empty row without
         *            naming at least one column name.  If your provided <code>values</code> is
         *            empty, no column names are known and an empty row can't be inserted.
         *            If not set to null, the <code>nullColumnHack</code> parameter
         *            provides the name of nullable column name to explicitly insert a NULL into
         *            in the case where your <code>values</code> is empty.
         * @param values this map contains the initial column values for the
         *            row. The keys should be the column names and the values the
         *            column values
         * @return the row ID of the newly inserted row, or -1 if an error occurred
         */
        public long insert(String table, String nullColumnHack, ContentValues values);
    ```

    使用示例代码片段
    ```
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        ContentValues values = new ContentValues();

        // 开始组装第一组数据
        values.put("name", "The Da Vinci Code");
        values.put("author", "Dan Brown");
        values.put("pages", 454);
        values.put("price", 16.96);

        //public long insert(String table, String nullColumnHack, ContentValues values);
        db.insert("Book", null, values); // 插入第一条数据
        values.clear();  
    ```

* 2、更新数据

    > SQLiteDatabase 中提供了一个update()方法用于更新数据，接收4个参数，如下：
    > * 第一个参数：表名
    > * 第二个参数：ContentValues对象，要把更新的数据在这里组装
    > * 第三个参数，第四个参数：用于约束更新某一行或某几行中的数据，不指定的话就默认更新所有行

    ```
        /**
         * Convenience method for updating rows in the database.
         *
         * @param 表名【table the table to update in】
         * @param ContentValues对象【values a map from column names to new column values. null is a】
         *            valid value that will be translated to NULL.
         * @param whereClause the optional WHERE clause to apply when updating.
         *            Passing null will update all rows.
         * @param whereArgs You may include ?s in the where clause, which
         *            will be replaced by the values from whereArgs. The values
         *            will be bound as Strings.
         * @return the number of rows affected
         */
        public int update(String table, ContentValues values, String whereClause, String[] whereArgs);
    ```

    使用示例代码片段

    ```
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        ContentValues values = new ContentValues();

        values.put("price", 10.99);

        db.update("Book", values, "name = ?", new String[]{"The Da Vinci Code"});
    ```

* 3、删除数据

    > SQLiteDatabase 中提供了一个delete()方法，专门用来删除数据，接收3个参数，如下：
    > * 第一个参数：表名
    > * 第二个参数、第三个参数：是用于约束删除某一行或某几行的数据，不指定的话默认删除所有行
    >

    ```
        /**
         * Convenience method for deleting rows in the database.
         *
         * @param table the table to delete from
         * @param whereClause the optional WHERE clause to apply when deleting.
         *            Passing null will delete all rows.
         * @param whereArgs You may include ?s in the where clause, which
         *            will be replaced by the values from whereArgs. The values
         *            will be bound as Strings.
         * @return the number of rows affected if a whereClause is passed in, 0
         *         otherwise. To remove all rows and get a count pass "1" as the
         *         whereClause.
         */
        public int delete(String table, String whereClause, String[] whereArgs);
    ```

    使用示例代码片段

    ```
        SQLiteDatabase db = dbHelper.getWritableDatabase();

        db.delete("Book", "pages > ?", new String[]{"500"});
    ```

* 4、查询数据

    > SQL 全称是 Structured Query Language【结构化查询语言】
    >
    > SQLiteDatabase 中提供了一个query()方法，用于对数据进行查询，这个方法的参数比较复杂，最短的重载方法也需要传入7个参数。
    > * 第一个参数：表名
    > * 第二个参数：用于指定去查询哪几列，如果不指定则默认查询所有列
    > * 第三个参数、第四个参数：用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据
    > * 第五个参数：用于指定需要去 group by的列，不指定则表示不对查询结果进行 groupby 操作
    > * 第六个参数：用于对groupby之后的数据进行进一步过滤，不指定则表示不进行过滤
    > * 第七个参数：用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。
    >

```
    /**
     * Query the given table, returning a {@link Cursor} over the result set.
     *
     * @param table The table name to compile the query against.
     * @param columns A list of which columns to return. Passing null will
     *            return all columns, which is discouraged to prevent reading
     *            data from storage that isn't going to be used.
     * @param selection A filter declaring which rows to return, formatted as an
     *            SQL WHERE clause (excluding the WHERE itself). Passing null
     *            will return all rows for the given table.
     * @param selectionArgs You may include ?s in selection, which will be
     *         replaced by the values from selectionArgs, in order that they
     *         appear in the selection. The values will be bound as Strings.
     * @param groupBy A filter declaring how to group rows, formatted as an SQL
     *            GROUP BY clause (excluding the GROUP BY itself). Passing null
     *            will cause the rows to not be grouped.
     * @param having A filter declare which row groups to include in the cursor,
     *            if row grouping is being used, formatted as an SQL HAVING
     *            clause (excluding the HAVING itself). Passing null will cause
     *            all row groups to be included, and is required when row
     *            grouping is not being used.
     * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
     *            (excluding the ORDER BY itself). Passing null will use the
     *            default sort order, which may be unordered.
     * @return A {@link Cursor} object, which is positioned before the first entry. Note that
     * {@link Cursor}s are not synchronized, see the documentation for more details.
     * @see Cursor
     */
    public Cursor query(String table, String[] columns, String selection,
            String[] selectionArgs, String groupBy, String having,
            String orderBy);


    /**
     * Query the given table, returning a {@link Cursor} over the result set.
     *
     * @param table The table name to compile the query against.
     * @param columns A list of which columns to return. Passing null will
     *            return all columns, which is discouraged to prevent reading
     *            data from storage that isn't going to be used.
     * @param selection A filter declaring which rows to return, formatted as an
     *            SQL WHERE clause (excluding the WHERE itself). Passing null
     *            will return all rows for the given table.
     * @param selectionArgs You may include ?s in selection, which will be
     *         replaced by the values from selectionArgs, in order that they
     *         appear in the selection. The values will be bound as Strings.
     * @param groupBy A filter declaring how to group rows, formatted as an SQL
     *            GROUP BY clause (excluding the GROUP BY itself). Passing null
     *            will cause the rows to not be grouped.
     * @param having A filter declare which row groups to include in the cursor,
     *            if row grouping is being used, formatted as an SQL HAVING
     *            clause (excluding the HAVING itself). Passing null will cause
     *            all row groups to be included, and is required when row
     *            grouping is not being used.
     * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
     *            (excluding the ORDER BY itself). Passing null will use the
     *            default sort order, which may be unordered.
     * @param limit Limits the number of rows returned by the query,
     *            formatted as LIMIT clause. Passing null denotes no LIMIT clause.
     * @return A {@link Cursor} object, which is positioned before the first entry. Note that
     * {@link Cursor}s are not synchronized, see the documentation for more details.
     * @see Cursor
     */
    public Cursor query(String table, String[] columns, String selection,
            String[] selectionArgs, String groupBy, String having,
            String orderBy, String limit);
```

<table border="2">
    <tr>
        <th>query()方法参数</th>
        <th>对应SQL部分</td>
        <th>描述</th>
    </tr>
    <tr>
        <td>table</td>
        <td>from table_name</td>
        <td>指定查询的表名</td>
    </tr>
    <tr>
        <td>columns</td>
        <td>select column1, column2</td>
        <td>指定查询的列名</td>
    </tr>
    <tr>
        <td>selection</td>
        <td>where column = value</td>
        <td>指定where的约束条件</td>
    </tr>
    <tr>
        <td>selectionArgs</td>
        <td>-</td>
        <td>为where重的占位符【?】提供具体的值</td>
    </tr>
    <tr>
        <td>groupBy</td>
        <td>group by column</td>
        <td>指定需要groupBy的列</td>
    </tr>
    <tr>
        <td>having</td>
        <td>having column = value</td>
        <td>对groupBy的结果进行进一步约束</td>
    </tr>
    <tr>
        <td>orderBy</td>
        <td>order by column1, column2</td>
        <td>指定查询结果的排序放式</td>
    </tr>
</table><br/><br/>

#### 3、使用 SQL 语句操作数据库

> 直接使用SQL来完成前面的CRUD操作

* 添加数据的方法

```
    db.execSQL("insert into Book (name, author, pages, price) values (?, ?, ?, ?)", new String[]{"The Da Vinci Code", "Dan Brown", "454", "16.96"});

    db.execSQL("insert into Book (name, author, pages, price) values (?, ?, ?, ?)", new String[]{"The Lost Symbol", "Dan Brown", "510", "19.95"});
```

* 更新数据的方法

```
    db.execSQL("update Book set price = ? where name = ?", new String[]{"10.99", "The Da Vinci Code"});
```

* 删除数据的方法

```
    db.execSQL("delete from Book where pages > ?", new String[]{"500"});
```

* 查询数据的方法

```
    db.rawQyery("select * from Book", null);
```

#### 4、使用 **LitePal** 操作数据库

> LitePal 是一款开源的 Android 数据库框架，它采用了对象关系映射（ORM）模式，并将我们平时开发最常用到的一些数据库功能进行了封装，使得不用编写一行SQL语句就可以完成各种建表和增删改查的操作

**LitePal的项目主页有详细的使用文档** 

[LitePal的项目主页地址](https://github.com/LitePalFramework/LitePal) 


------
------


## 第七章 跨进程共享数据 探究 **Content Provider**

-----

### 7.1、Content Provider 简介

> Content Provider 主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问的数据的安全性。

> **使用Content Provider是Android实现跨程序共享数据的标准方式**

### 2、Android 运行时权限

> Android 开发团队在 Android 6.0 系统中引用了运行时权限这个功能，从而更好地保护用户的安全行业隐私。

#### 7.2、Android权限机制

* Android 现在将权限归为两大类：一类是普通权限；一类是危险权限。
    * 普通权限：是指那些不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，而不需要用户再去手动操作了。
    * 危险权限：表示那些可能会触及用户隐私，或者对设备安全性造成影响的权限。比如：获取设备联系人信息；定位设备的地理位置信息等，对于这部分权限，必须由用户手动点击授权才可以，否则程序就无法使用相应的功能。

* Android中所有的危险权限，一共是9组24个权限。如下：
>
> CALENDAR (日历) 【权限组名】
> > 【权限名】
> > * READ_CALENDAR
> > * WRITE_CALENDAR
>
> CAMERA (相机)
> > * CAMERA
>
> LOCATION
> > * ACCESS_FINE_LOCATION
> > * ACCESS_COARSE_LOCATION
>
> MICROPHONE
> > * RECORD_AUDIO
>
> PHONE
> > * READ_PHONE_STATE
> > * CALL_PHONE
> > * READ_CALL_LOG
> > * WRITE_CALL_LOG
> > * ADD_VOICEMAIL
> > * USE_SIP
> > * PROCESS_OUT_CALLS
>
> SENSORS
> > * SEND_SMS
> > * RECEIVE_SMS
> > * READ_SMS
> > * RECEIVE_WAP_PUSH
> > * RECEIVE_MMS
>
> STORAGE
> > * READ_EXTERNAL_STORAGE
> > * WRITE_EXTERNAL_STORAGE
>
>

**⚠️注意：上表中的每个危险权限都有一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权，那么该权限所对应的权限组中所有其他权限也同时会被授权。**

[查看Android系统中完整的权限表](https://developer.android.google.cn/reference/android/Manifest.permission.html)

#### 在程序运行时申请权限

代码示例
```
    /***
     * 设置运行时权限 --- 打电话
     */
    private void callPhone() {
        if(ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CALL_PHONE}, 1);
        } else {
            call();
        }
    }

    // 申请运行时权限的回调函数
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        switch (requestCode) {
            case 1:
                if(grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    call();
                } else {
                    Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();
                }
                break;
            default:
                break;
        }
    }

    // 实现打电话的方法
    private void call() {
        try {
            Intent intent = new Intent(Intent.ACTION_CALL);
            intent.setData(Uri.parse("tel:10086"));
            startActivity(intent);
            // 注意：这样实现的打电话的功能，在低于Android 6.0系统的手机上是可以正常运行的，但是在 Android 6.0 或更高版本系统的手机上运行，会报错 Permission Denial

        } catch (SecurityException e) {
            e.printStackTrace();
        }
    }

```

上面的代码已经将将运行时权限的完整流程都覆盖了。运行时权限的核心就是在程序运行过程中由用户授权我们去执行某些危险操作，程序不得擅自做主去执行这些危险操作。
> * 第一步 先判断用户是不是已经给过授权了，借助 ContextCompact.checkSelfPermission() 方法。将方法的返回值和 PackageManager.PERMISSION_GRANTED做比较，相等说明用户已经授权，不相等表示用户没有授权。
>    > checkSelfPermission() 方法接收两个参数：第一个参数是Context，第二个参数是具体的权限名，比如打电话的权限名是Manifest.permission.CALL_PHONE
> 
> * 第二步 
>   1. 如果已经授权，直接执行拨打电话的逻辑操作，即上面示例代码中的call()方法。
>   2. 如果没有授权，则需要调用ActivityCompact.requestPermissions()方法来向用户申请权限。
>   > requestPermissions()方法接收3个参数：第一个参数是Activity的实例；第二个参数是一个String数组，我们要把申请的权限名放到数组中即可；第三个参数是请求码，只要是唯一值就可以了，示例代码中传入1。
> 
>   > 调用完 requestPermissions()方法后，系统会弹出一个权限申请对话框，然后用户可以选择同意 或者 拒绝 我们的权限申请，不管是哪种结果，最终都会回调到 onRequestPermissionsResult()方法，而授权的结果会封装在 grantResults参数中。

### 7.3、访问程序中的数据

#### 7.3.1 ContentResolver 的基本用法

* 如果想要访问 **Content Provider** 中的共享数据，就一定要借助ContentResolver类，通过Cotext中的 **getContentResolver()** 方法获取该类的实例
    > ContentResolver中提供了一系列的方法用于对数据进行CRUD操作
    > > * insert() 用于添加数据
    > > * update() 用于更新数据
    > > * delete() 用于删除数据
    > > * query() 用于查询数据

* ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个Uri参数（**内容URI**）代替，内容URI给 ContentProvider中的数据建立了唯一标识符，它主要由两部分组成：**authority** 和 **path**。
    > * authority 是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。比如程序的包名为 com.example.app，则该程序的authority可以命名为 com.example.app.provider
    > * ptah 是用于对同一应用程序中不同表做区分的，通常都会添加到 authority 后面。比如程序数据库中有两张表 table1 和 table2，则path可以命名为：/table1 和 /table2
    
    > 最后需要在内容URI前面加上协议声明 **content://**

    ```
        // 内容 URI 最标准的格式写法如下：
        content://com.emample.app.provider/table1
        content://com.emample.app.provider/table2
    ```

* 查询表1中的数据
    ```
        Uri uri = Uri.prase("content://com.emample.app.provider/table1");

        Cursor cursor = getContentResolver().query(
            uri,
            projection,
            selection,
            selectionArgs,
            sortOrder
        )

        if(cursor != null) {
            while(cursor.moveToNext()) {
                String column1 = cursor.getString(cursor.getColumnIndex("column1"));

                int column2 = cursor.getInt(cursor.getColumnIndex("column2"));
                
            }

            cursor.close();
        }
    ```

    > 参数详解

    <table style="border: 1">
        <tr>
            <th>query()方法参数</th>
            <th>对应SQL部分</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>uri</td>
            <td>form table_name</td>
            <td>指定查询某个对应程序下的某张表</td>
        </tr>
        <tr>
            <td>projection</td>
            <td>select column1, column2</td>
            <td>指定查询的列名</td>
        </tr>
        <tr>
            <td>selection</td>
            <td>where column = value</td>
            <td>指定where的约束</td>
        </tr>
        <tr>
            <td>selectionArgs</td>
            <td>-</td>
            <td>为where中的占位符（?）提供具体的值</td>
        </tr>
        <tr>
            <td>orderBy</td>
            <td>order by column1, column2</td>
            <td>指定查询结果的排序方式</td>
        </tr>
    </table>

* 向表中添加一条记录
    ```
        Uri uri = Uri.prase("content://com.emample.app.provider/table1");

        ContentValues values = new ContentValues();
        values.put("column1" , "text");
        values.put("colums2", 1);

        getContentResolver().insert(uri, values);
    ```

* 更新表中的数据

    ```
        Uri uri = Uri.prase("content://com.emample.app.provider/table1");
        ContentValues values = new ContentValues();
        values.put("column1", "");
        getContentResolver().update(
            uri,
            values,
            "column1 = ? and colum2 = ?",
            new String[] {"text", "1"}
        );

    ```

* 删除表中的数据

    ```
        Uri uri = Uri.prase("content://com.emample.app.provider/table1");
       
        getContentResolver().delete(
            uri,
            "colum2 = ?",
            new String[] {"1"}
        );

    ```

### 7.4、创建自己的ContentProvider

#### 7.4.1、创建ContentProvider的步骤
> 1）通过继承ContentProvider的方式来创建一个自己的ContentProvider。ContentProvider 类中提供了6个抽象方法。
```
    public class MyContentProvider extends ContentProvider {

        @Override
        public boolean onCreate() {
            return false;
        }

        @Nullable
        @Override
        public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
            return null;
        }

        @Nullable
        @Override
        public String getType(Uri uri) {
            return null;
        }

        @Nullable
        @Override
        public Uri insert(Uri uri, ContentValues values) {
            return null;
        }

        @Override
        public int delete(Uri uri, String selection, String[] selectionArgs) {
            return 0;
        }

        @Override
        public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
            return 0;
        }
    }
```

> 6个方法的介绍
> * onCreate() 初始化ContentProvider的时候调用。
> > 通常会在这里完成对数据库的创建和升级操作，返回true表示ContentProvider初始化成功，返回false则表示失败。⚠️注意：只有当存在ContentResolver尝试访问我们程序中的数据时，ContentProvider才会被初始化
> 
> * query() 从ContentProvider中查询数据。
> > * 使用uri参数来确定查询哪张表
> > * projection参数用于确定查询的列
> > * selection 和 selectionArgs 参数用于约束查询哪些行
> > * sortOrder参数用于对结果行进行排序
> 
> > 查询的结果存放在Cursor中
>
> * insert() 向ContentProvider中添加一条数据。
> > 使用uri参数确定表,待添加的数据保存在ContentValues对象中。添加完成后，返回用于表示这条记录的URI
>
> * update() 更新数据， 受影响的行数将作为返回值返回
>
> * delete() 删除数据， 被删除的行数作为返回值返回
>
> * getType() 根据传入的内容来返回相应的MIME类型
>



回顾一下：
标准的内容URI格式：

```
content://com.example.app.provider/table1
```

表示调用方法期望访问 com.example.app这个应用中的table1表中的数据。除此外，我们还可以在这个内容URI的后面加一个id，如下所示：

```
content://com.example.app.provider/table1/1
```

表示调用方法期望访问的是com.example.app这个应用中table1表中id为1的数据。

内容 URI 的格式主要有以上两种，以路劲结尾就表示访问该表中所有的数据，以 id 结尾就表示期望访问该表中拥有相应 id 的数据。可以使用通配符的方式来分别匹配这两种格式的内容URI，规则如下：

> \* : 表示匹配任意长度的字符
> \# : 表示匹配任意长度的数字

一个能够匹配table1表中任意的内容URI格式可以写成：
```
content://com.example.app.provider/table1/*
```

一个能够匹配table1表中任意一行的内容URI格式可以写成
```
content://com.example.app.provider/table1/#
```

> 2）借助 UriMatcher这个类实现匹配内容URI的功能。
> > * UriMatcher类中提供一个 addURI()方法，可以分别把 authority、path 和 自定义的代码传进去。
> > * 调用UriMatcher的match() 方法可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所应的自定义代码

```
    public static final int TABLE1_DIR = 1;
    public static final int TABLE1_ITEM = 2;
    public static final int TABLE2_DIR = 3;
    public static final int TABLE2_ITEM = 4;\

    private static UriMatcher uriMatcher;

    static {
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI("org.liti.firstcode.provider", "table1", TABLE1_DIR);
        uriMatcher.addURI("org.liti.firstcode.provider", "table1/#", TABLE1_ITEM);
        uriMatcher.addURI("org.liti.firstcode.provider", "table2", TABLE2_DIR);
        uriMatcher.addURI("org.liti.firstcode.provider", "table2/#", TABLE2_ITEM);
    }

    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {

        switch(uriMatcher.match(uri)) {
            case TABLE1_DIR: // 查询 table1 表中的所有数据

                break;
            case TABLE1_ITEM: // 查询 table1 表中的单条数据

                break;
            case TABLE2_DIR:

                break;
            case TABLE2_ITEM:

                break;
        }

        return null;
    }

```

> 3）getType()方法，它是所有ContentProvider都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI对应的MIME字符串主要由3部分组成，Android对这3部分做了格式规定
>
> > * 必须以 **vnd** 开头
> > * 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/。
> > * 最后接上 vnd.< authority >.< path >
>

对于 content://com.example.app.provider/table1/ 这个内容URI，它所对应的MIME类型字符串可以写成：

```
    vnd.android.cursor.dir/vnd.com.example.app.provider.table1
```

对于 content://com.example.app.provider/table1/1 这个内容URI，它所对应的MIME类型字符串可以写成：

```
    vnd.android.cursor.item/vnd.com.example.app.provider.table1
```

实现getType()方法中的逻辑

```
    private static final String URI_AUTHORITY = "org.liti.firstcode.provider";

    public String getType(Uri uri) {

        switch(uriMatcher.match(uri)) {
            case TABLE1_DIR: // 查询 table1 表中的所有数据
                return "vnd.android.cursor.dir/vnd." + URI_AUTHORITY + ".table1";
            case TABLE1_ITEM: // 查询 table1 表中的单条数据
                return "vnd.android.cursor.item/vnd." + URI_AUTHORITY + ".table1";
            case TABLE2_DIR:
                return "vnd.android.cursor.dir/vnd." + URI_AUTHORITY + ".table2";
            case TABLE2_ITEM:
                return "vnd.android.cursor.item/vnd." + URI_AUTHORITY + ".table2";
        }

        return null;
    }
```

### 7.5、GIT时间 —— 版本控制工具进阶

#### 7.5.1、忽略文件

* Git提供了一种可配性很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的目录下是否存在一个名为 **.gitignore** 的文件，如果存在的话，就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意： .gitignore 文件中指定的文件或目录可以用 “*” 通配符

#### 7.5.2、查看修改的内容

* git status  命令可以查看至上次提交后文件修改的内容

* git diff 命令可以查看所有文件的更改内容，后面接文件名（包含路径

#### 7.5.3、撤销未提交的修改

* git checkout filename 命令这种撤销方式只适用于那些还没有执行过 add 命令的文件


对于已经执行过 add 命令的文件，我们应该先对其取消添加，然后才可以撤回提交
* git reset HEAD filename  取消添加，然后执行 git checkout 命令撤回提交

#### 7.5.4、查看提交记录

* git log 

* git log 提交记录id -l 表示只看其中的一条记录

* git log 提交记录id -p 查看这条记录的具体修改内容

  
























